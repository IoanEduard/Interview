Floyd Warshall
 
 ----
|    |
1 -- 2
|   /|
|  / |
| /  |
|/   |
3 -- 4

1 -> 2 w = 9
1 -> 3 w = -4
2 -> 1 w = 6
3 -> 2 w = 5
4 -> 3 w = 1

We have to find "All Pair Shortest Path"
For example we take vertex 1 as a source vertex and we find shortest distance to each vertex
 
1 -> 2
  -> 3
  -> 4

2 -> 1
  -> 3
  -> 4

3 -> 1
  -> 2
  -> 3

4 -> 1
  -> 2
  -> 3

  All Pairs shortest path problem
  Dijsktra algorithm would find shortest path from a given source 
  Using Dijsktra algorithm for this case we would have to apply it 4 times to find All pair shortest path

  Floyd Warshall is using DP technique, breaking down a big problem into smaller problems
    - works on positive and negative weights 


  1 to 2
  we can have 1 to 3 then to 2
  we can have 4 to 3 to 2

  we take 1 as middle element then we find the shortest distance between each pair of distances
  then we take 2 as middle element then 3 then 4 and find shortest distance between each pair of vertexes

  Step 1:
  Draw a distance matrix
  D0  = 1    2    3   4 
      1 0    9    -4  inf
      2 6    0    inf 2
      3 inf  5    0   inf
      4 inf  inf  1   0 

  Diagonal is always 0, from 1 to 1 is obviously 0
  we fill the matrix with weights on corresponding vertexes Pairs

  D0 is the initial distance matrix

  We take vertex 1 as middle vertex and then find out the shortest distance between each pair of vertexes via vertex 1

  D1 =  1   2   3   4
      1 0   9   2   2
      2 6   0   inf 2 
      3 inf 5   0   inf
      4 inf inf 1   0

  D0[2,3] = inf
  D0[2,1]+D0[1,3] = 6 + -4 
                    2 < inf // we replace with 2

  D0[2,4] = D0[2,1]+D0[1,4];
          = 6+inf = inf
          inf > 2 // we leave 2 alone

  D0[3,2] = D0[3,1]+D0[1,2]
          = inf+0 = inf
          inf > 5 // we leave 5

 // we do for the rest the same.

 Now we find the shortest distance pair path via vertex 2
 D2 = 1   2   3   4
    1 0   9
    2     0
    3     5   0
    4     inf      0

 D2 = 1   2     3   4
    1 0   9    -4   11
    2 11  0     2   2
    3 11  5     0   7
    4 inf inf   1   0

  D1[1,3] = D1[1,2]+D1[2,3]
          = 9 + 2 == 11
          11 > -4 // we leave -4

  D1[1,4] = D1[1,2] + D1[2,4]
          = 9+2 = 11
          11 < inf // we update to 11

  D1[3,1]=D1[3,2]+D1[2,1]
         = 5+6 = 11
         11 < inf

  // we fill out the rest

  D3 = 1    2    3    4
    1  0        -4  
    2       0    2
    3  11   5    0    7
    4            1    0

  D3 = 1    2    3    4
    1  0    1    -4   3
    2  6    0    2    2
    3  11   5    0    7
    4  12   6    1    0

  D2[1,2] = D2[1,3]+D2[3,2]
          = -4 + 5 = 1
          1 < 9 // we update

  D2[1,4] = D2[1,3] +D2[3,4]
          = -4 + 7  = 3
          3 < 11

  // we continue the rest
  D4 = 1    2    3    4
    1  0              3 
    2       0         2  
    3            0    7
    4  12   6    1    0

  D3[1,2] = D3[1,4]+D3[4,2]
    1      = 3+6 update to 1
  D3[1,3] = D3[1,4] + D3[4,3]
    -4    < 3+1

  D4 = 1    2    3    4
    1  0    1   -4    3 
    2  6    0    2    2  
    3  11   5    0    7
    4  12   6    1    0

  D4 will give the shortest path between each pair of vertexes
  Choose 3 ->  1  = 11
            -> 2  = 5
            -> 4  = 7

  Formula:
  
  D^k[i,j] = min { D^k-1[i,j], D^k-1[i,k] + D^k-1[k,j]}
  D3[1,2] = D3[1,4] + D3[4,2]
    1     < 3 + 6 = 9
    k = 4
    i = 1
    j = 2

    3 for loops

    for(k = 1 to 4)
      for(i = 1 to 4) row
        for(j = 1 to 4) col
        {
          // formula
        }

if is a sparse graph better use Dijsktra


